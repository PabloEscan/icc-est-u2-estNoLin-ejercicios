# Estructuras No Lineales ‚Äì Ejercicios √Årboles

Este proyecto contiene la soluci√≥n a cuatro ejercicios pr√°cticos sobre estructuras de datos tipo √°rbol binario, como parte del aprendizaje de estructuras no lineales en Java. Cada ejercicio se encuentra organizado en su propia carpeta, siguiendo la convenci√≥n de paquetes y buenas pr√°cticas.

---

## Identificaci√≥n del Estudiante (Obligatorio)

Antes de comenzar a programar o ejecutar el proyecto, **debes completar tu nombre y correo institucional en el archivo `student.env`** que se encuentra en la ra√≠z del proyecto. Este archivo es necesario para validar tu identidad como autor del trabajo.

### ¬øPor qu√© es obligatorio?

Este proyecto utiliza una verificaci√≥n autom√°tica que valida que has ingresado tu informaci√≥n personal. Si no lo haces:

- Al ejecutar el proyecto (`App.java`) ver√°s este mensaje de error:
```
‚ùå Debes completar STUDENT_NAME y STUDENT_EMAIL en student.env
```
- No podr√°s enviar tu c√≥digo (`push`) al repositorio si tienes activado el sistema de validaci√≥n local.
- Las pruebas autom√°ticas en GitHub Actions tambi√©n fallar√°n si no detectan tu nombre y correo.

### ¬øQu√© debo hacer?

1. Abre el archivo `student.env` que ya est√° creado en el proyecto.
2. Rellena tus datos:

```
STUDENT_NAME=Tu Nombre Completo
STUDENT_EMAIL=tu.correo@institucion.edu.ec
```

3. **No borres estas l√≠neas ni cambies los nombres de las variables.**
4. Guarda los cambios y vuelve a ejecutar el programa o hacer push.

> üí° Este mecanismo asegura la autor√≠a del c√≥digo y que cada estudiante reciba su evaluaci√≥n autom√°tica de forma personalizada.

---

## Explicaci√≥n para el estudiante

```
src/
‚îÇ
‚îú‚îÄ‚îÄ Materia/
‚îÇ
‚îú‚îÄ‚îÄ Ejercicio_01_insert/
‚îú‚îÄ‚îÄ Ejercicio_02_invert/
‚îú‚îÄ‚îÄ Ejercicio_03_listLeves/
‚îî‚îÄ‚îÄ Ejercicio_04_depth/
```

---

## Descripci√≥n de Ejercicios

### Ejercicio 01: Insertar en un √Årbol Binario de B√∫squeda (BST)

Carpeta: `Ejercicio_01_insert`  
Implementa un algoritmo para insertar nodos en un √Årbol Binario de B√∫squeda.

**Input de ejemplo:** `[5, 3, 7, 2, 4, 6, 8]`  
**Output esperado:**

```
    5
  3   7
 2 4 6 8
```

---

### Ejercicio 02: Invertir un √Årbol Binario

üìÇ Carpeta: `Ejercicio_02_invert`  
Dada la ra√≠z de un √°rbol binario, el algoritmo devuelve su versi√≥n invertida (espejo).

**Input de ejemplo:**

```
    4
  2   7
1  3 6  9
```

**Output esperado:**

```
    4
  7   2
9  6 3  1
```

---

### Ejercicio 03: Listar Niveles en Listas Enlazadas

üìÇ Carpeta: `Ejercicio_03_listLeves`  
Devuelve una lista enlazada con los nodos por nivel. Si hay N niveles, se obtienen N listas.

**Input de ejemplo:**

```
    4
  2   7
1  3 6  9
```

**Output esperado:**

```
4  
2 ‚Üí 7  
1 ‚Üí 3 ‚Üí 6 ‚Üí 9
```

---

### Ejercicio 04: Calcular la Profundidad M√°xima

Carpeta: `Ejercicio_04_depth`  
Calcula la profundidad m√°xima de un √°rbol binario (la longitud del camino m√°s largo desde la ra√≠z hasta una hoja).

**Input de ejemplo:**

```
    4
  2   7
1  3  
8
```

**Output esperado:** `4`

---

## Indicaciones Generales

* Lee cuidadosamente el enunciado de cada ejercicio.  
* Cada carpeta debe contener:  
  * C√≥digo fuente Java.  
  * Casos de prueba.  
  * Comentarios claros.  
* Realiza commit y push con el mensaje:

  ```
  Estructuras No Lineales ‚Äì Ejercicios √Årboles
  ```  
* En el AVAC, sube la **URL del repositorio** con el c√≥digo.

---

## No se calificar√° si:

* No hay commit con los ejercicios.  
* No se incluye este README explicativo.  
* Las clases o m√©todos no siguen los nombres requeridos.

---

## R√∫brica de Calificaci√≥n

| **Criterio**       | **Descripci√≥n**                                                                       | **Puntaje** |
| ------------------ | ------------------------------------------------------------------------------------- | ----------- |
| **Informe**        | No hay informe                                                                        | 0 pts       |
|                    | Informe parcial **sin explicaci√≥n** de cada m√©todo                                    | 1 pt        |
|                    | Informe parcial **con explicaci√≥n** de cada m√©todo                                    | 2 pts       |
|                    | Informe completo                                                                      | 3 pts       |
| **Funcionamiento** | No implementado                                                                       | 0 pts       |
|                    | Implementado parcialmente: <br>‚Ä¢ Ejercicio 1 y 4 ‚Üí 2 pts<br>‚Ä¢ Ejercicio 2 y 3 ‚Üí 4 pts | 2‚Äì4 pts     |
|                    | C√≥digo funcional pero **no pasa todas las pruebas**                                   | 6 pts       |
|                    | C√≥digo funcional y **pasa todas las pruebas correctamente**                           | 7 pts       |

---

## üß† An√°lisis del C√≥digo Desarrollado

### Ejercicio 01: Insertar en un √Årbol Binario de B√∫squeda (BST)

Se desarroll√≥ la clase `InsertBST` con el m√©todo `insert(Node root, int value)` para insertar elementos en un √Årbol Binario de B√∫squeda (BST).  
El algoritmo utiliza recursi√≥n para recorrer el √°rbol:

- Si el nodo actual es `null`, se crea un nuevo nodo con el valor.
- Si el valor es menor que el nodo actual, se inserta en el sub√°rbol izquierdo.
- Si es mayor, se inserta en el sub√°rbol derecho.

Este proceso asegura que el √°rbol mantenga la propiedad de BST, donde todos los valores a la izquierda de un nodo son menores, y a la derecha son mayores. No se permite insertar valores duplicados.

---

### Ejercicio 02: Invertir un √Årbol Binario

Se implement√≥ la clase `InvertBinaryTree` con el m√©todo `invertTree(Node root)` para invertir un √°rbol binario, tambi√©n conocido como reflejo o espejo del √°rbol original.  
El algoritmo recorre el √°rbol de manera recursiva e intercambia los nodos izquierdo y derecho en cada nivel.

Pasos clave:  
1. Si el nodo actual es `null`, se retorna `null` (caso base).  
2. Se intercambian los nodos izquierdo y derecho usando una variable temporal.  
3. Se repite el proceso de inversi√≥n recursivamente en ambos sub√°rboles.

Este enfoque garantiza que todo el √°rbol se invierta desde la ra√≠z hasta las hojas, manteniendo la estructura pero reflejada horizontalmente.

---

### Ejercicio 03: Listar Niveles en Listas Enlazadas

En este ejercicio se desarroll√≥ la clase `ListLevels` con el m√©todo `listLevels(Node root)`, que recorre un √°rbol binario por niveles (BFS) y devuelve una lista de listas enlazadas, donde cada sublista representa los nodos presentes en un nivel del √°rbol.

Pasos clave del algoritmo:  
1. Se utiliza una **cola (`Queue`)** para realizar el recorrido por niveles.  
2. En cada iteraci√≥n del bucle, se procesa un nivel completo midiendo el tama√±o actual de la cola.  
3. Se guarda una lista con los nodos del nivel actual.  
4. Al final, se agregan las listas de cada nivel al resultado.

Este m√©todo permite representar visualmente el √°rbol por niveles y se puede usar para mostrarlo as√≠:
```
4  
2 ‚Üí 7  
1 ‚Üí 3 ‚Üí 6 ‚Üí 9
```

---

### Ejercicio 04: Calcular la Profundidad M√°xima

Se desarroll√≥ la clase `Depth` con el m√©todo `maxDepth(Node root)` para calcular la **profundidad m√°xima** de un √°rbol binario.  
El objetivo es determinar la longitud del camino m√°s largo desde la ra√≠z hasta una hoja.

Funcionamiento del algoritmo:  
1. Si el nodo es `null`, se retorna `0` como caso base.  
2. Se llama recursivamente al sub√°rbol izquierdo y al derecho.  
3. Se calcula cu√°l de los dos tiene mayor profundidad.  
4. Se suma `1` por el nodo actual.

Este m√©todo garantiza encontrar la profundidad m√°s larga, es decir, el n√∫mero m√°ximo de niveles en el √°rbol.

---

## Contribuir

Para contribuir a este proyecto, por favor crea un fork y env√≠a una solicitud de extracci√≥n, o simplemente abre un issue con tus comentarios y sugerencias.

---

## Autores

- [PABLO TORRES] - Desarrollo inicial
- [PABLO ESCANDON] - Estudiante 